**`INPUT`**

Encode the following text to a Caesar cipher. The shift is 3. rakibo zlmqwe

**`INTERMEDIATE REASONING CHAIN`** (Thought for 21 seconds)

> Okay, the user wants to encode "rakibo zlmqwe" using a Caesar cipher with a shift of 3. Let me start by recalling how Caesar cipher works. Each letter is shifted a certain number of places down the alphabet. In this case, shift by 3.
> 
> First, I need to handle each character individually. Let me break down the original text: r, a, k, i, b, o, space, z, l, m, q, w, e.
> 
> Starting with 'r'. The alphabet positions are a=0, b=1,... z=25. So 'r' is the 17th letter (since a is 0). Adding 3 gives 20, which is 'u'.
> 
> Next is 'a'. That's 0 +3 =3, which is 'd'.
> 
> Then 'k' which is 10. 10+3=13, which is 'n'.
> 
> 'i' is 8 +3=11, which is 'l'.
> 
> 'b' is 1 +3=4, 'e'.
> 
> 'o' is 14 +3=17, which is 'r'.
> 
> Space remains as is.
> 
> Now the next part: 'z' is 25. Adding 3 would normally be 28, but since the alphabet wraps around, subtract 26. 28-26=2, which is 'c'.
> 
> 'l' is 11 +3=14, 'o'.
> 
> 'm' is 12 +3=15, 'p'.
> 
> 'q' is 16 +3=19, 's'.
> 
> 'w' is 22 +3=25, 'z'.
> 
> 'e' is 4 +3=7, 'h'.
> 
> Putting it all together: u d n l e r  c o p s z h. So the ciphertext should be "udnler copszh". Let me double-check each letter to make sure I didn't make a mistake.
> 
> r→u, correct. a→d, yes. k→n, i→l, b→e, o→r. Then z→c, l→o, m→p, q→s, w→z, e→h. Looks right. Spaces are kept, so the result is "udnler copszh".

**`FINAL OUTPUT`**

The encoded text using a Caesar cipher with a shift of **3** is:

**udnler copszh**

---

**Explanation:**  
Each letter in the original text is shifted forward by **3** positions in the alphabet. For example:
- **r** → **u** (r → s → t → u)
- **z** → **c** (z → a → b → c)
- Non-alphabetic characters (like spaces) remain unchanged.
